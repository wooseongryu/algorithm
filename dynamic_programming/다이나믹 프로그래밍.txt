dynamic programming을 사용하기 위한 두가지 조건은
최적 부분 구조와 중복되는 부분 문제가 있다

# 최적 부분 구조(optimal substructure)
최적 부분 구조가 있다는 건 부분 문제들의 최적의 답을 이용해서
기존 문제의 최적의 답을 구할 수 있다는 것이다

# 중복되는 부분 문제(overlapping subproblems)
피보나치를 계산할 때 만약 fib(5)라면
fib(4)와 fib(3)부분문제를 해결해야 한다
fib(4)를 해결하기 위해선 fib(3)과 fib(2)를 해결해야 한다
여기서 fib(3)을 중복으로 계산해야 한다
이런 경우를 중복되는 부분 문제라고 한다

합병 정렬(merge sort)은 리스트를 나누어 왼쪽 반을 해결하는 과정과 오른쪽 반을 해결하는 과정이 완전히 독립적이므로
중복되지 않는 부분 문제(non-overlapping subproblems)다

# dynamic programming
어떤 문제의 최적 부분 구조가 있다는 건 기존 문제를 부분 문제로 나눠서 풀 수 있다는 말이다.
부분 문제로 나누어 풀게되면 중복되는 부분 문제들이 있을 수 있다.
이런 비효율을 해결하기 위함이 dynamic programming이다.
다이나믹 프로그래밍은 한 번 계산한 결과를 재활용하는 방식을 말한다.

다이나믹 프로그래밍을 구현하는 방법은 memoization, tabulation 두 가지로 나뉜다.

# memoization
중복되는 계산은 한 번만 계산 후 메모하는 방식이다.
재귀를 사용한다
피보나치를 계산할 때 fib(5) = fib(4) + fib(3)이렇게 위에서 아래로 하향식 접근을 한다.

# tabulation
반복문을 사용한다
피보나치를 계산할 때 fib(1)을 구하고 fib(2)를 구하고... 이렇게 아래에서 위로 상향식 접근을 한다.

n      | 1 | 2 | 3 | 4 | 5 |
fib(x) | 1 | 1 | 2 | 3 | 5 |

이렇게 왼쪽에서 부터 테이블을 채워나가는 느낌이다.

# memoization vs tabulation
둘 다 중복되는 부분 문제의 비효율을 해결한다

memoization은 재귀를 사용하기 때문에 재귀호출이 너무 많이 생기면 스택이 쌓여 오류가 날 수 있다
위에서 부터 필요한 계산이 뭔지 요구를 하기 때문에 필요 없는 계산은 하지 않는다.
모든 부분 문제를 해결하지 않아도 된다면 이 방식이 더 효율적일 수 있다.

tabulation은 반복문을 사용하기 때문에 스택이 쌓여 오류가 날 일이 없다
표를 하나씩 채워 올라가는 것이기 때문에 중간에 필요 없는 값 까지 계산하며 가야한다.
모든 부분 문제를 해결해야 한다면 이 방식이 더 효율적이다
재귀함수 호출이 없고 cache는 리스트로 구현되기 때문에 연산이 빠르다

# 다이나믹 프로그래밍의 공간 최적화
피보나치를 구할 때
테이블을 모두 채워나가기 때문에 공간 복잡도는 O(n)이다.
여기서 피보나치n을 구하기 위해선 피보나치 n - 1과 n - 2가 필요하니 두개의 변수를 돌려가며 n을 구할 수 있다.
그러면 공간 복잡도는 O(1)이 된다.
이렇게 모든 계산값을 저장할 필요가 없는 경우에는 공간을 최적화 시키는게 좋다
